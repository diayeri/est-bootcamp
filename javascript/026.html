<!DOCTYPE html>
<html lang="ko-KR">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>연산 - 비교연산</title>
    <style></style>
  </head>
  <body>
    <main>
      <h1>비교연산</h1>
    </main>
    <script src="../common.js"></script>
    <script>
      // 2. 비교연산
      // 결과는 boolean

      // >, < : 크기를 비교하는 대소관계 연산자
      // 숫자형으로 형 변환이 일어남
      // 피연산자가 모두 문자열일 때는 -> 문자열로 "사전식" 비교
      let x = 20;
      let y = "10"; // 숫자 10으로 변환됨
      y = 10n; // 숫자 10으로 변환됨 (bigInt와 타입만 다를뿐 30n -> 30)
      console.log("x > y", x > y);
      console.log("x < y", x < y);

      let z = 20;
      console.log("x >= z", x >= z);
      console.log("x <= z", x <= z);

      console.log("100" < "2"); // 문자 -> true
      console.log("100" < 2); // 숫자 -> false

      console.log("hello" < 2); // NaN < 2
      console.log("hello" > 2); // NaN > 2
      console.log("hello" <= "hello"); // 이건또 되네...ㅋ
      console.log(NaN <= NaN); // false
      // NaN은 모든 비교 연산에서 false 반환

      // == 동등 / != 부등
      // "숫자형으로" 자동형변환이 일어나서 값을 비교함
      console.log("----동등, 부등연산자----");
      let num1 = 30;
      let num2 = 20;

      // == 동등 연산자
      console.log(num1 == 30);
      console.log(num1 == "30");
      console.log(num1 == 30n);
      console.log(num1 == num2); // 값이 다를경우 -> false
      console.log(num1 == "30n");
      console.log(+"30n"); // NaN

      // != 부등 연산자
      console.log(num1 != num2);
      console.log(num1 != "30");
      console.log(num1 != 30n);
      console.log(num1 != "30n");

      // 자동형변환
      // 원시 타입의 비교
      // 원시 타입: 비교연산하려는 값들의 타입이 다를 때, number로 변환하여 비교
      console.log("----자동 형 변환----");
      console.log(+false);
      console.log(+true);

      console.log(+"234");
      console.log(+"hello");
      console.log(+"");

      console.log(+null);
      console.log(+undefined);

      console.log("----자동 형 변환, 다른 형 비교----");
      console.log("----원시타입의 비교----");
      console.log("" == false);
      console.log("hello" == true);
      console.log("hello" == undefined);
      // NaN비교는 (NaN끼리도) false만 나온다

      // NaN비교를 위해서는 isNaN, Number.isNaN 메서드를 사용
      console.log("isNaN", isNaN("hello")); // 형변환 O (숫자로 변환한 뒤에 NaN 판별)
      console.log("Number.isNaN", Number.isNaN("hello")); // 형변환 X (그대로 NaN 판별)

      console.log(null == undefined);
      // null, undefined 는 본인/서로 비교할 때만 true
      // null == null
      // null == undefined
      // undefined == undefined

      // 객체 타입의 비교
      // 주소값을 비교하게 됨!
      console.log("----객체타입의 비교----");
      const obj1 = { a: "1", b: "2" };
      const obj2 = { a: "1", b: "2" };
      const obj3 = obj1;

      console.log(obj1 == obj2);
      console.log(obj1 == obj3);

      console.log([] == []);
      // 빈 배열도 주소값을 가진다

      // 객체와 원시타입의 비교
      // 객체를 원시 타입에 맞추어 변환하여 비교 (number로 형변환 된다고는 못할듯)
      console.log("----객체와 원시타입의 비교----");
      console.log([1, 2] == "1,2");
      console.log([] == 0);
      console.log("+[]", +[]);
      console.log(["키위"] == "키위"); // true

      // === 일치 / !== 불일치
      // === 일치 연산자
      // 값과 타입을 모두 비교함 (타입 변환이 없음)
      console.log("----일치 연산자----");
      let num3 = 30;
      let num4 = 20;

      console.log(num3 === 30);
      console.log(num3 === "30");
      console.log(num3 === 30n);

      console.log(num3 !== 30);
      console.log(num3 !== "30");
      console.log(num3 !== 30n);
      console.log(num3 !== num4);

      const obj4 = [1, 2, 3, 4];
      const obj5 = [1, 2, 3, 4];
      const obj6 = obj4;
      console.log(obj4 === obj5);
      console.log(obj4 === obj6);
    </script>
  </body>
</html>
